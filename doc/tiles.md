---
title: 麻雀プログラム 麻雀牌
---

## オブジェクトとしての麻雀牌

論理的には麻雀牌を Unicode のコードポイントで表現してもいいが、
以下、クラス `Tile` で表現するのと仮定し、必要となる属性や操作を述べる。

### 牌を生成する

どの牌も Singleton であるとみなせることに注意する。
例えば一萬の牌は四つあるが、いずれにも区別はない。
オブジェクトで扱うか、タイプとして扱うかという問題も出てくる。

* コードポイントから生成
* `unicodedata.name` から生成
* 既存の牌オブジェクトから生成
  * コピー
  * ドラ表示牌からドラ、またはその逆

### 牌一枚に対する属性や操作

* ID: これは Unicode のコードポイントで代用可能（ただしソート関連操作のキーにはそのまま使わない）。
* 名称（例：東、中、一萬）
* 分類判定：字牌、風牌、三元牌、么九牌、中張牌、萬子、筒子、索子。
* 数牌限定：書いてある数
* ゲーム中限定
  * ドラ表示牌からドラを判定する、またはその逆方向
  * ドラである（局の属性かもしれない）
    * 裏ドラである
    * カンドラである

### 牌二枚に対する属性や操作

* 搭子である
  * 対子である
  * 数牌ならば両面・辺張・嵌張待ちの形か

### 牌三枚または面子に対する属性や操作

* 順子である
* 刻子である

## 手牌に対する属性や操作

### 副露面子

* 牌の列：牌 3..4
* 面子の種類：順子・刻子・槓子
* 誰から鳴いたか：下家・対面・上家

### 手牌情報

* 有効牌を解消する。
  * 国士無双、七対子、標準形とで分ける。

* シャンテン数を判定する
  * 国士無双としてのシャンテン数
  * 七対子としてのシャンテン数
  * 標準形としてのシャンテン数：これがいちばん難しい。再帰的に？

* 副露と非副露を分けて持つ。手番でないときは非副露部分では：
  * ハダカタンキの場合は 1 枚。常にテンパイとみなす。
  * 3 副露の場合は 13 - 9 = 4 枚。
    * 一面子あるとみなせる場合はテンパイ。345X
    * 対子＋搭子とみなせる場合はテンパイ。XX46
    * 対子＋非搭子は 1 シャンテン。XXYZ
    * 非搭子＋非搭子は 2 シャンテン。
  * 2 副露の場合は 13 - 6 = 7 枚。
  * 1 副露の場合は 13 - 3 = 10 枚。
  * 門前のときには 13 枚。

おそらくイーシャンテンのときにシステムは有効牌を把握している必要がある。
有効牌をツモると即テンパイと判定できるし、待ち牌もすべて判明している状態になる。
これを一般化すると n シャンテンのときに有効牌を把握している必要がある。
有効牌を持ってきた瞬間 n - 1 シャンテンとし、手に入れたときに有効牌も更新できる。

### 理牌

プレイヤーの便宜を図るため自動理牌を実装するものとする。
このオプションが有効なときには、配牌直後および手番の直後に自動的に手牌が理牌されるものとする。

萬子・筒子・索子・風牌・三元牌をグループ化し、それぞれのグループ内でソートするものとする。
このグループの順序はシステムが勝手に決めてよい。
配牌中に所属グループが出現する順序と一致させるのが自然だろう。

ソートには Unicode のコードポイントを援用してよい（ただし三元牌は注意）。

### 同色数牌シャンテン数解決

目標

* テストのために「同色の数牌 13 枚からなる手牌」の全パターンを列挙する。
  * ランダムにいくつか生成する関数は実装可能。36 枚から同一牌 4 枚を超える重複なしで 13 枚組み上げる。
  * 全パターンは未着手。
* 「同色の数牌 13 枚からなる手牌」のシャンテン数・有効牌・待ち牌・待ちの種類を解決する。

$n_i\;(i = 1, \dotsc, 9)$ を数牌 $i$ の枚数とする。このとき

$$
\sum_{i = 1}^9 n_i = 13,\;0 \le n_i \le 4
$$

を満たす組 $(n_1, \dotsc, n_9)$ を求めたい。組み合わせでいい。

```text
num of cases: 32
Counter({1: 7, 2: 1, 4: 1})
Counter({1: 7, 3: 2})
Counter({1: 6, 2: 2, 3: 1})
Counter({1: 6, 3: 1, 4: 1})
Counter({1: 5, 2: 4})
Counter({1: 5, 2: 2, 4: 1})
Counter({1: 5, 3: 2, 2: 1})
Counter({1: 5, 4: 2})
Counter({1: 4, 2: 3, 3: 1})
Counter({1: 4, 2: 1, 3: 1, 4: 1})
Counter({1: 4, 3: 3})
Counter({2: 5, 1: 3})
Counter({1: 3, 2: 3, 4: 1})
Counter({1: 3, 2: 2, 3: 2})
Counter({1: 3, 4: 2, 2: 1})
Counter({1: 3, 3: 2, 4: 1})
Counter({2: 4, 1: 2, 3: 1})
Counter({1: 2, 2: 2, 3: 1, 4: 1})
Counter({3: 3, 1: 2, 2: 1})
Counter({1: 2, 4: 2, 3: 1})
Counter({2: 6, 1: 1})
Counter({2: 4, 1: 1, 4: 1})
Counter({2: 3, 3: 2, 1: 1})
Counter({2: 2, 4: 2, 1: 1})
Counter({3: 2, 1: 1, 2: 1, 4: 1})
Counter({3: 4, 1: 1})
Counter({4: 3, 1: 1})
Counter({2: 5, 3: 1})
Counter({2: 3, 3: 1, 4: 1})
Counter({3: 3, 2: 2})
Counter({4: 2, 2: 1, 3: 1})
Counter({3: 3, 4: 1})
```

例：`Counter({3: 2, 1: 1, 2: 1, 4: 1})` というのは $3+3+1+2+4=13$ を意味する。
萬子だとすると、一萬から九萬の 9 種から 5 種を各項に対して割り当てる順列か。
$3+3$ の部分だけ重複を考慮する必要がある。`perm(9, 5) // 2 = 7560` 通り。
その他の場合に対する計算方法がこれを一般化することで得られる。
検算していないが `perm(9, len(counter))` を `counter.values()` の各項の階乗で除算するようなものだろう。
しかしこの計算だけでテーブル探索作戦は無茶だと判断していいだろう。

